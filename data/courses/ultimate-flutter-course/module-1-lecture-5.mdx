---
/* title: Lecture 3 - Structure and Linting */
/* description: Introduction to the Ultimate Flutter Course */
vimeo: xxxxxxx 
/* github: https://github.com/Robert-Brunhage-Organization/movie_recommendation_app_course/commit/454914801e9b6758249a6e36e8a6bf8f52d93a16 */
author: Robert Brunhage
lastmod: 10-30-2022
---

## Notes

UnconstrainedBox can seem a bit complex and we didn't go through it that much. I recommend reading the documentation here: [UnconstrainedBox](https://api.flutter.dev/flutter/widgets/UnconstrainedBox-class.html) to get a clearer understanding of it if you didn't understand it. [This article](https://dev.to/pedromassango/unconstrainedbox-is-your-friend-tip-5-19cl) is also great to get a better understanding of it.


To get a better understanding of constraints in Flutter I recommend [this article](https://docs.flutter.dev/development/ui/layout/constraints).


Immutability

Immutability is great for keeping state/objects predictable. We will go over immutability more in module 2 but if you want to learn more about it you can also check out my [video about it](https://www.youtube.com/watch?v=nUF0IrEjWj0)


Overriding equals and hashcode

I personally use a VSCode extension called "**Dart Data Class Generator**" which allows me to generate the boilerplate code needed. Another great approach is to use the "**Equatable**" package. Personally, I try to go with the normal approach first and then opt to **Equatable** if I feel like I need it (it reduces the code needed but adds another dependency).
